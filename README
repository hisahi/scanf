
WORK IN PROGRESS! Some things may still be buggy. Issues and pull requests
are welcome. Additional tests are also very much welcome.

This is a freestanding implementation of scanf (the standard C library function
for reading formatted input). It does not have any dependencies other than the
C89 standard library, specifically the following headers:
    <limits.h>
    <stdarg.h>
    <stddef.h>
    <stdint.h> (optional, C99 only)
    <ctype.h> (optional, if SCANF_INTERNAL_CTYPE = 0)
    <float.h> (optional, if SCANF_DISABLE_SUPPORT_FLOAT = 0)
    <math.h> (optional, if SCANF_NOMATH = 0)

The prototypes for the scanf functions are the same as in the standard:

    int scanf(const char* format, ...);
    int sscanf(const char *s, const char* format, ...);

In addition, a function that takes in a function pointer is available:

    int fctscanf(int (*getch)(void* data), void (*ungetch)(int c, void* data), void* data, const char* format, ...);

All of these functions also have a v* variant that takes in a va_list.

    int vscanf(const char* format, va_list arg);
    int vsscanf(const char *s, const char* format, va_list arg);
    int vfctscanf(int (*getch)(void* data), void (*ungetch)(int c, void* data), void* data, const char* format, va_list arg);

In addition to these, you can also find

    int spscanf(const char **sp, const char* format, ...);
    int vspscanf(const char **sp, const char* format, va_list arg);

which take a const char ** and will update the pointer such that it points to
the first conflicting character (or end of the string).

For scanf, two functions called getch_() and ungetch_() should be defined,
the prototypes of which should be

    int getch_(void);
    void ungetch_(int);

getch_ shall return an int that can be represented as an unsigned char
(zero or positive) or a negative integral value that represents the end of file.

ungetch_ shall push a character back into the stream such that the next getch_
call will return the character pushed. ungetch_ will not be called more than
once for every *scanf call, nor will it be called more than once between calls
to getch_.

The functions given to (v)fctscanf shall function identically, except also take
a parameter of type void * which will have the same value as passed to
(v)fctscanf. ungetch may be left as NULL for (v)fctscanf in which case it will
not be called.

This implementation of scanf is intended to be completely standards-compliant
and support all the same format specifiers as a standards-compliant
implementation. It is thread-safe and reentrant (does not use any static
storage), nor does it require any dynamic allocations (malloc). Primary focus is
on portability and robustness, while secondary focus is on maximizing
performance and minimizing code size.

Known caveats:
- Long length specifier for wide characters (%lc, %ls, %l[) is not supported.
  Read in multibyte characters and use mbstowcs yourself.
  At some point if there is enough demand, I'll probably implement a
  wscanf.c/wscanf.h that comes with wide functions (w*) as well as multibyte
  ones, but requires more functions (getwch_, ungetwch_, mbrtowc_, wcrtomb_)
- Long floating point numbers might not be converted correctly if they do not
  fit into the buffer.
- The only supported locale is the C locale; no locale-specific formatting
  is allowed.

To use this library, simply include scanf.h, compile and link scanf.c into
your program and implement getch_ and ungetch_ as documented above. You may
also want to look at the defines below to customize your build.

Defines:
    SCANF_DISABLE_SUPPORT_FLOAT (default: undefined)
        Define as 1 to disable floating-point support
    SCANF_DISABLE_SUPPORT_LONG_LONG (default: 1, or undefined if C99)
        Define as 1 to disable long long support
    SCANF_ASCII (default: 1)
        Define as 0 if the following ASCII invariants are not necessarily true
            '0123456789' are consecutive characters
            'ABCDEFGHIJKLMNOPQRSTUVWXYZ' are consecutive characters
            'abcdefghijklmnopqrstuvwxyz' are consecutive characters
            uppercase letter bitwise ORed with 0x20 converts into lowercase
    SCANF_INTERNAL_CTYPE (default: 1 if freestanding impl detected, else 0)
        Define as 1 to use internal ctype functions instead of including
        <ctype.h>. Requires SCANF_ASCII.
    SCANF_NOMATH (default: 1 if freestanding impl detected, else 0)
        Define as 1 to not use <math.h> as a dependency. It is only needed
        for floating-point support; SCANF_NOMATH has no effect if
        SCANF_DISABLE_SUPPORT_FLOAT is defined to be true.
    SCANF_NOPOW (default: 1)
        Define as 0 to use pow() from <math.h>. Has no effect is SCANF_NOMATH
        or SCANF_DISABLE_SUPPORT_FLOAT is defined to be true.
        Setting SCANF_NOPOW to 0 may speed up conversions to float.
    SCANF_LOGN_POW (default: 1)
        Uses a O(log(n)) integer power algorithm instead of O(n).
        Should almost always work, but define to 0 if it causes issues.
    SCANF_INFINITE (default: 1 if C99 and SCANF_NOMATH not defined, else 0)
        Define as 1 to enable INFINITY/NAN support. Macros called INFINITY
        and NAN must be defined. SCANF_INFINITE has no effect if
        SCANF_DISABLE_SUPPORT_FLOAT is defined to be true.
    SCANF_FAST_SCANSET (default: 1 if CHAR_BIT == 8, else 0)
        Makes scanset scanning faster but takes up more memory.
    SCANF_BINARY (default: 1)
        Adds a new custom formatter %b for binary numbers. You should consider
        increasing SCANF_ATON_BUFFER_SIZE if setting this to 1.
    SCANF_SECURE (default: 0)
        Triggers a read failure if a %s or %[ format specifier does not specify
        a maximum length/width.
    SCANF_ATON_BUFFER_SIZE (default: 72 if SCANF_BINARY, else 32)
        Size of buffer allocated on the stack for reading integral
        numbers (through %i, %d, %u, %o, %x) for conversion into a string.
    SCANF_ATOD_BUFFER_SIZE (default: 32)
        Same as SCANF_ATON_BUFFER_SIZE, but used only for decimal numbers
        (floating point exponent as well as field width).
    SCANF_ATOF_BUFFER_SIZE (default: 48)
        Size of buffer allocated on the stack for reading floating point
        numbers for conversion into a string.

Tests for scanf are included in the test program test-scanf.cc under the
test folder.
